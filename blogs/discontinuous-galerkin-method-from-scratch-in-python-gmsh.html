<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2025-02-05 Wed 17:51 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>DG Method From Scratch (in Python) - Gmsh</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css">
<link href="https://fonts.googleapis.com/css2?family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&display=swap" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="../assets/css/styles.css" />
<script type="module" src="../assets/js/navbar.js"></script>
<script type="module" src="../assets/js/main.js"></script>
<base target="_blank">
</head>
<body>
<div id="preamble" class="status">
<nav>
    <!-- Checkbox for toggling menu -->
    <input type="checkbox" id="check">
    <!-- Menu icon -->
    <label for="check" class="checkbtn">
      <i class="fas fa-bars"></i>
    </label>
    <!-- Site logo -->
    <label class="logo"><a href="/index.html">Go Van Go</a></label>
    <!-- Navigation links -->
    <ul class="navbar-ul">
      <li><a target="_self" class="active" href="/index.html">Home</a></li>
      <li><a target="_self" href="/about.html">About</a></li>
      <li><a target="_self" href="/blog.html">Blog</a></li>
      <li><a target="_self" href="/contact.html">Contact</a></li>
    </ul>
  </nav>
</div>
<div id="content" class="content">
<h1 class="title">DG Method From Scratch (in Python) - Gmsh
<br>
<span class="subtitle">Making a mesh and extracting information</span>
</h1>
<p class="date"><i>last update: Feb 4, 2025</i></p>
<div id="outline-container-org417023e" class="outline-2">
<h2 id="org417023e">Article Motivation</h2>
<div class="outline-text-2" id="text-org417023e">
<blockquote>
<ul class="org-ul">
<li>How do you make a mesh on Gmsh?<br></li>
<li>How do I loop over elements or faces?<br></li>
<li>How do I get the normal to each face?<br></li>
<li>How do I find the boundary nodes and faces?<br></li>
<li>Create a python class called <code>Mesh</code> with functions that return important information about the Gmsh mesh.<br></li>
</ul>
</blockquote>
</div>
</div>
<div id="outline-container-org4dcfe3d" class="outline-2">
<h2 id="org4dcfe3d">Introduction</h2>
<div class="outline-text-2" id="text-org4dcfe3d">
<p>
Gmsh is an <b>open source</b> 3D finite element mesh generator [<a href="#citeproc_bib_item_1">1</a>]. Let's use it to produce triangle and tetrahedral meshes. Then, we'll extract all the information we need to do a finite element simulation (like vertices for each cell, normal to each face, boundary faces, which elements are touching and on which face).<br>
</p>
</div>
</div>
<div id="outline-container-org6ade896" class="outline-2">
<h2 id="org6ade896">Creating a 2D and 3D mesh in Gmsh</h2>
<div class="outline-text-2" id="text-org6ade896">
<p>
Let's create some meshes that we can use as examples.<br>
</p>

<p>
We'll start with a 2D mesh. We'll make a simple ellipse and we'll do it using Gmsh's built in geometry kernel. We'll save the following as <code>2d-ellipse.geo</code><br>
</p>

<div class="org-src-container">
<pre class="src src-gmsh"><span style="color: #D8DEE9;">cm</span> = 1e-02; <span style="color: #6f7787;">// </span><span style="color: #6f7787;">centimeters</span>
<span style="color: #D8DEE9;">a</span> = 6 * cm; <span style="color: #6f7787;">// </span><span style="color: #6f7787;">Semi-major axis</span>
<span style="color: #D8DEE9;">b</span> = 4 * cm; <span style="color: #6f7787;">// </span><span style="color: #6f7787;">Semi-minor axis</span>
<span style="color: #D8DEE9;">Lc</span> = 0.01;  <span style="color: #6f7787;">// </span><span style="color: #6f7787;">characteristic cell length </span>

<span style="color: #6f7787;">// </span><span style="color: #6f7787;">Define center and ellipse points</span>
<span style="color: #81A1C1;">Point</span>(1) = {0, 0, 0, Lc};
<span style="color: #81A1C1;">Point</span>(2) = {a, 0, 0, Lc};
<span style="color: #81A1C1;">Point</span>(3) = {0, b, 0, Lc};
<span style="color: #81A1C1;">Point</span>(4) = {-a, 0, 0, Lc};
<span style="color: #81A1C1;">Point</span>(5) = {0, -b, 0, Lc};

<span style="color: #6f7787;">// </span><span style="color: #6f7787;">Define ellipse using center and points</span>
<span style="color: #81A1C1;">Ellipse</span>(1) = {2, 1, 3};
<span style="color: #81A1C1;">Ellipse</span>(2) = {3, 1, 4};
<span style="color: #81A1C1;">Ellipse</span>(3) = {4, 1, 5};
<span style="color: #81A1C1;">Ellipse</span>(4) = {5, 1, 2};

<span style="color: #6f7787;">// </span><span style="color: #6f7787;">Define surface</span>
<span style="color: #81A1C1;">Curve Loop</span>(5) = {1, 2, 3, 4};
<span style="color: #81A1C1;">Plane Surface</span>(6) = {5};
</pre>
</div>

<p>
We can then run the following code to produce a <code>.msh</code> file, Gmsh's own file type for storing mesh data.<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">gmsh -2 2d-ellipse.geo -o 2d-ellipse.msh
</pre>
</div>

<p>
Now let's use the <i>OpenCASCADE</i> geometry Kernel that is available using Gmsh's python API. We'll create the following file called <code>3d-torus.py</code><br>
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #81A1C1;">import</span> gmsh
<span style="color: #81A1C1;">import</span> sys

<span style="color: #6f7787;"># </span><span style="color: #6f7787;">initialize gmsh</span>
gmsh.initialize(sys.argv)

<span style="color: #6f7787;"># </span><span style="color: #6f7787;">Same parameters as 2D problem</span>
<span style="color: #D8DEE9;">cm</span> = 1e-02;
<span style="color: #D8DEE9;">a</span> = 6 * cm;
<span style="color: #D8DEE9;">b</span> = 4 * cm;
<span style="color: #D8DEE9;">Lc</span> = 0.01;

<span style="color: #6f7787;"># </span><span style="color: #6f7787;">Create an ellipse using OpenCASCADE</span>
<span style="color: #D8DEE9;">ellipse</span> = gmsh.model.occ.addTorus(0, 0, 0, a, b)

<span style="color: #6f7787;"># </span><span style="color: #6f7787;">Synchronize the model</span>
gmsh.model.occ.synchronize();

<span style="color: #6f7787;"># </span><span style="color: #6f7787;">Generate a 2D mesh</span>
gmsh.model.mesh.generate(2)

<span style="color: #6f7787;"># </span><span style="color: #6f7787;">Save the mesh as a .msh file</span>
gmsh.write(<span style="color: #A3BE8C;">"3d-torus.msh"</span>)

<span style="color: #6f7787;"># </span><span style="color: #6f7787;">Run the GUI</span>
gmsh.fltk.run()

gmsh.finalize()
</pre>
</div>

<p>
Running this python file with <code>python 3d-torus.py</code> will produce our 3D <code>.msh</code> file.<br>
</p>
</div>
</div>
<div id="outline-container-org15cd7b6" class="outline-2">
<h2 id="org15cd7b6">Writing a Mesh class in python</h2>
<div class="outline-text-2" id="text-org15cd7b6">
<div class="emphasis" id="orga9b4a38">
<p>
Our goal is to create a python class called <code>Mesh</code> that can easily provide the following information:<br>
</p>
<ul class="org-ul">
<li><code>dimension</code> - dimension of mesh<br></li>
<li><code>num_elements</code> - number of elements in the mesh<br></li>
<li><code>verticies[i]</code> - coordinates for vertex <code>i</code> <br></li>
<li><code>edges2Elements[i]</code> - the elements that include edge <code>i</code><br></li>
<li><code>faces2Elements[i]</code> - the elements that include face <code>i</code><br></li>
<li><code>elements2Elements[i]</code> - the elements adjacent to element <code>i</code><br></li>
<li><code>normal[i]</code> - the normal vector to face <code>i</code><br></li>
<li><code>jacobians[i]</code> - the jacobian matrix of element <code>i</code> (used for mapping from reference element)<br></li>
<li><code>determinants[i]</code> - the determinant of element <code>i</code>'s Jacobian matrix (used for mapping from reference element)<br></li>
</ul>

</div>
<p>
We can visualize the mesh using the built in GUI for Gmsh. However, were going to need to get a bunch of the information from Gmsh into numpy, so lets figure out how to do that.<br>
</p>

<div class="extra" id="org345139a">
<p>
Naming conventions for meshes can vary from person to person. In this cite we'll stick to the following.<br>
</p>

<p>
A <b>mesh</b> has <b>cells</b>. 3D cells (tetrahedron in our case) have <b>faces</b>, <b>edges</b>, and <b>vertices</b>. All of these are examples of <b>entities</b>.<br>
</p>

<p>
An <b>element</b> refers to a <b>finite element</b> which can have quadrature points called <b>nodes</b>.<br>
</p>

<p>
See the posts about <a href="https://govango.org/blogs/what-is-a-computational-mesh">meshes</a> and <a href="https://govango.org/blogs/discontinuous-galerkin-method-from-scratch-in-python-the-finite-element">finite elements</a> for more information.<br>
</p>

<p>
Unfortunately Gmsh uses element and node terminology for meshes, so you might see them interchanged at times.<br>
</p>

</div>

<p>
The first thing we'll want to do is extract all the vertices and plot them using matplotlib. Lets create a python file called <code>mesh-with-matplotlib.py</code><br>
</p>

<p>
Lets get familiar with some of the Gmsh functionality with the following simple code.<br>
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #81A1C1;">import</span> gmsh
<span style="color: #81A1C1;">import</span> pdb

gmsh.initialize()
gmsh.<span style="color: #81A1C1;">open</span>(file_path)

<span style="color: #D8DEE9;">entities</span> = gmsh.model.getEntities() 
<span style="color: #81A1C1;">breakpoint</span>()
</pre>
</div>

<p>
This puts us into the python debugger where we can start to poke around. Typing <code>(PDB) entities</code> returns the following:<br>
</p>
<div class="org-src-container">
<pre class="src src-bash">[(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (1, 1), (1, 2), (1, 3), (1, 4), (2, 6)] <span style="color: #6f7787;"># </span><span style="color: #6f7787;">for 2d-ellipse.msh</span>
[(0, 1), (1, 1), (1, 2), (2, 1), (3, 1)]  <span style="color: #6f7787;"># </span><span style="color: #6f7787;">for 3d-torus.msh </span>
</pre>
</div>

<p>
This is a list of all the entities in the model as <code>(dimension,tag)</code> pairs.<br>
</p>

<p>
So <code>(0,1)</code> means there is a point (zero dimensional object) with a tag of 1.<br>
</p>

<div class="emphasis" id="orgc820d70">
<p>
<i>What is a tag in Gmsh?</i><br>
</p>

<p>
A tag is just a global identification model for the entity. It is strictly positive and, when combined with the dimension, uniquely defines any entity. From the documentation:<br>
</p>

<ul class="org-ul">
<li>each point must possess a unique tag;<br></li>
<li>each curve must possess a unique tag;<br></li>
<li>each surface must possess a unique tag;<br></li>
<li>each volume must possess a unique tag.<br></li>
</ul>

</div>

<p>
Our <code>2d-ellipse.msh</code> has 5 points, 4 curves, and 1 surface.<br>
</p>

<p>
Our <code>3d-torus.msh</code> file has 1 point, 2 curves, 1 surface, and 1 volume.<br>
</p>

<p>
Using example 2.22 from <a href="https://gmsh.info/doc/texinfo/gmsh.html#x1">the official gmsh tutorial</a>, we can print the following information about our <code>2d-ellipse.msh</code> file.<br>
</p>

<div class="org-src-container">
<pre class="src src-bash">Info    : Reading <span style="color: #A3BE8C;">'2d-ellipse.msh'</span>...
Info    : 10 entities
Info    : 114 nodes
Info    : 229 elements
Info    : Done reading <span style="color: #A3BE8C;">'2d-ellipse.msh'</span>
<span style="color: #88C0D0;">Entity</span> (0, 1) of type Point
 - Mesh has 1 nodes and 1 elements
<span style="color: #88C0D0;">Entity</span> (0, 2) of type Point
 - Mesh has 1 nodes and 1 elements
 - Upward adjacencies: [1 4]
<span style="color: #88C0D0;">Entity</span> (0, 3) of type Point
 - Mesh has 1 nodes and 1 elements
 - Upward adjacencies: [1 2]
<span style="color: #88C0D0;">Entity</span> (0, 4) of type Point
 - Mesh has 1 nodes and 1 elements
 - Upward adjacencies: [2 3]
<span style="color: #88C0D0;">Entity</span> (0, 5) of type Point
 - Mesh has 1 nodes and 1 elements
 - Upward adjacencies: [3 4]
<span style="color: #88C0D0;">Entity</span> (1, 1) of type Discrete curve
 - Mesh has 7 nodes and 8 elements
 - Upward adjacencies: [6]
 - Downward adjacencies: [2 3]
<span style="color: #88C0D0;">Entity</span> (1, 2) of type Discrete curve
 - Mesh has 7 nodes and 8 elements
 - Upward adjacencies: [6]
 - Downward adjacencies: [3 4]
<span style="color: #88C0D0;">Entity</span> (1, 3) of type Discrete curve
 - Mesh has 7 nodes and 8 elements
 - Upward adjacencies: [6]
 - Downward adjacencies: [4 5]
<span style="color: #88C0D0;">Entity</span> (1, 4) of type Discrete curve
 - Mesh has 7 nodes and 8 elements
 - Upward adjacencies: [6]
 - Downward adjacencies: [5 2]
<span style="color: #88C0D0;">Entity</span> (2, 6) of type Discrete surface
 - Mesh has 81 nodes and 192 elements
</pre>
</div>

<p>
Luckily Gmsh allows to get a lot more information from the mesh. Fro example:<br>
</p>

<ul class="org-ul">
<li>We can get all the nodes (vertices) that lie on a boundary using <code>gmsh.model.mesh.getElementEdgeNodes()</code><br></li>
<li>We can get the nodes on the faces of entities using <code>gmsh.model.mesh.getElementFaceNodes()</code><br></li>
<li>We can get the Jacobian of an element using <code>gmsh.model.mesh.getJacobians()</code><br></li>
<li>We can get the surface normal of every face<br></li>
</ul>

<p>
Since <code>gmsh.model.mesh.getEdges()</code> and <code>gmsh.model.mesh.getFaces()</code> return in the same order as the elements, we can do things like make a dictionary that tells us the connections between edges and elements, and faces and elements.<br>
</p>

<p>
Using all this information, lets create a file called <code>mesh.py</code> and in that file well create the following python class called <code>Mesh</code>.<br>
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #81A1C1;">class</span> <span style="color: #8FBCBB;">Mesh3d</span>:
    <span style="color: #81A1C1;">def</span> <span style="color: #88C0D0;">__init__</span>(<span style="color: #81A1C1;">self</span>, msh_file):
        gmsh.initialize()
        gmsh.<span style="color: #81A1C1;">open</span>(msh_file)

        <span style="color: #81A1C1;">self</span>.<span style="color: #D8DEE9;">num_vertices</span> = 0
        <span style="color: #81A1C1;">self</span>.<span style="color: #D8DEE9;">num_elements</span> = 0
        <span style="color: #81A1C1;">self</span>.<span style="color: #D8DEE9;">vertexCoordinates</span> = []
        <span style="color: #81A1C1;">self</span>.<span style="color: #D8DEE9;">element2vertices</span> = []
        <span style="color: #81A1C1;">self</span>.<span style="color: #D8DEE9;">element2elements</span> = []
        <span style="color: #81A1C1;">self</span>.<span style="color: #D8DEE9;">element2faces</span> = []
        <span style="color: #81A1C1;">self</span>.<span style="color: #D8DEE9;">faceNormals</span> = []
        <span style="color: #81A1C1;">self</span>.<span style="color: #D8DEE9;">jacobians</span> = {}
        <span style="color: #81A1C1;">self</span>.<span style="color: #D8DEE9;">determinants</span> = {}
        
        <span style="color: #81A1C1;">self</span>._extract_mesh_info()
        <span style="color: #81A1C1;">self</span>._build_connectivityMatricies()
        <span style="color: #81A1C1;">self</span>._compute_jacobians()

        gmsh.finalize()

    <span style="color: #81A1C1;">def</span> <span style="color: #88C0D0;">_extract_mesh_info</span>(<span style="color: #81A1C1;">self</span>):
        <span style="color: #6f7787;"># </span><span style="color: #6f7787;">get vertex information </span>
        <span style="color: #D8DEE9;">ntags</span>, <span style="color: #D8DEE9;">coords</span>, <span style="color: #D8DEE9;">_</span> = gmsh.model.mesh.getNodes(4)
        <span style="color: #81A1C1;">self</span>.<span style="color: #D8DEE9;">num_vertices</span>= <span style="color: #81A1C1;">len</span>(ntags)
        <span style="color: #81A1C1;">self</span>.<span style="color: #D8DEE9;">vertexCoordinates</span> = coords.reshape(-1, 3)

        <span style="color: #6f7787;"># </span><span style="color: #6f7787;">get element information</span>
        <span style="color: #6f7787;"># </span><span style="color: #6f7787;">get all the nodes from tetrahedrons (elementType = 4)</span>
        <span style="color: #D8DEE9;">nodeTags</span>, <span style="color: #D8DEE9;">_</span>, <span style="color: #D8DEE9;">_</span> = gmsh.model.mesh.getNodesByElementType(4) 
        <span style="color: #81A1C1;">self</span>.<span style="color: #D8DEE9;">num_elements</span> = <span style="color: #81A1C1;">int</span>(<span style="color: #81A1C1;">len</span>(nodeTags)/4) 
        <span style="color: #81A1C1;">self</span>.<span style="color: #D8DEE9;">elements2vertices</span> = nodeTags.reshape(-1, 4).astype(<span style="color: #81A1C1;">int</span>)

    <span style="color: #81A1C1;">def</span> <span style="color: #88C0D0;">_build_connectivityMatricies</span>(<span style="color: #81A1C1;">self</span>):
        <span style="color: #78808f;">"""tetrahedral face connect algorithm from Toby Isaac"""</span>
        <span style="color: #D8DEE9;">num_faces</span> = 4
        <span style="color: #D8DEE9;">K</span> = <span style="color: #81A1C1;">self</span>.num_elements 
        <span style="color: #D8DEE9;">EtoV</span> = <span style="color: #81A1C1;">self</span>.elements2vertices
        <span style="color: #D8DEE9;">num_vertices</span> = <span style="color: #81A1C1;">self</span>.num_vertices 
        
        <span style="color: #6f7787;"># </span><span style="color: #6f7787;">create list of all faces</span>
        <span style="color: #D8DEE9;">faceVertices</span> = np.vstack((EtoV[:, [0, 1, 2]],
                            EtoV[:, [0, 1, 3]],
                            EtoV[:, [1, 2, 3]],
                            EtoV[:, [0, 2, 3]]))
        <span style="color: #6f7787;"># </span><span style="color: #6f7787;">sort each row from low to high for hash algorithm</span>
        <span style="color: #D8DEE9;">faceVertices</span> = np.sort(faceVertices, axis=1) - 1
         
        <span style="color: #6f7787;"># </span><span style="color: #6f7787;">unique hash for each set of three faces by their vertex numbers</span>
        <span style="color: #D8DEE9;">faceHashes</span> = faceVertices[:, 0] * num_vertices * num_vertices  + \
                     faceVertices[:, 1] * num_vertices + \
                     faceVertices[:, 2] + 1

        <span style="color: #6f7787;"># </span><span style="color: #6f7787;">vertex id from 1 - num_vertices * num_elements</span>
        <span style="color: #D8DEE9;">vertex_ids</span> = np.arange(1, num_faces*K+1)
       
        <span style="color: #6f7787;"># </span><span style="color: #6f7787;">set up default element to element and element to faces connectivity</span>
        <span style="color: #D8DEE9;">EtoE</span> = np.tile(np.arange(1, K+1)[:, np.newaxis], (1, num_faces))
        <span style="color: #D8DEE9;">EtoF</span> = np.tile(np.arange(1, num_faces+1), (K, 1))

        <span style="color: #6f7787;"># </span><span style="color: #6f7787;">build a master matrix (mappingTable) that we will solve by </span>
        <span style="color: #6f7787;"># </span><span style="color: #6f7787;">sorting by one column to create the connectivity matricies</span>
        <span style="color: #D8DEE9;">mappingTable</span> = np.column_stack((faceHashes,
                                        vertex_ids,
                                        np.ravel(EtoE, order=<span style="color: #A3BE8C;">'F'</span>),
                                        np.ravel(EtoF, order=<span style="color: #A3BE8C;">'F'</span>)))
        
        <span style="color: #6f7787;"># </span><span style="color: #6f7787;">Now we sort by global face number.</span>
        <span style="color: #D8DEE9;">sorted_mapTable</span>= np.array(<span style="color: #81A1C1;">sorted</span>(mappingTable, key=<span style="color: #81A1C1;">lambda</span> x: (x[0], x[1])))
        
        <span style="color: #6f7787;"># </span><span style="color: #6f7787;">find matches in the sorted face list</span>
        <span style="color: #D8DEE9;">matches</span> = np.where(sorted_mapTable[:-1, 0] == sorted_mapTable[1:, 0])[0]
        
        <span style="color: #6f7787;"># </span><span style="color: #6f7787;">make links reflexive</span>
        <span style="color: #D8DEE9;">matchL</span> = np.vstack((sorted_mapTable[matches], sorted_mapTable[matches + 1]))
        <span style="color: #D8DEE9;">matchR</span> = np.vstack((sorted_mapTable[matches + 1], sorted_mapTable[matches]))
        
        <span style="color: #6f7787;"># </span><span style="color: #6f7787;">insert matches</span>
        <span style="color: #D8DEE9;">EtoE_tmp</span> = np.ravel(EtoE, order=<span style="color: #A3BE8C;">'F'</span>) - 1
        <span style="color: #D8DEE9;">EtoF_tmp</span> = np.ravel(EtoF, order=<span style="color: #A3BE8C;">'F'</span>) - 1
        EtoE_tmp[matchL[:, 1] - 1] = (matchR[:, 2] - 1)
        EtoF_tmp[matchL[:, 1] - 1] = (matchR[:, 3] - 1)
        
        <span style="color: #D8DEE9;">EtoE</span> = EtoE_tmp.reshape(EtoE.shape, order=<span style="color: #A3BE8C;">'F'</span>)
        <span style="color: #D8DEE9;">EtoF</span> = EtoF_tmp.reshape(EtoF.shape, order=<span style="color: #A3BE8C;">'F'</span>)

        <span style="color: #81A1C1;">self</span>.<span style="color: #D8DEE9;">element2elements</span> = EtoE
        <span style="color: #81A1C1;">self</span>.<span style="color: #D8DEE9;">element2faces</span> = EtoF

    <span style="color: #81A1C1;">def</span> <span style="color: #88C0D0;">_compute_jacobians</span>(<span style="color: #81A1C1;">self</span>):
        <span style="color: #6f7787;"># </span><span style="color: #6f7787;">get local coordinates of the verticies in the</span>
        <span style="color: #6f7787;"># </span><span style="color: #6f7787;">reference tetrahedron</span>
        <span style="color: #D8DEE9;">name</span>, <span style="color: #D8DEE9;">dim</span>, <span style="color: #D8DEE9;">order</span>, <span style="color: #D8DEE9;">numNodes</span>, <span style="color: #D8DEE9;">localCoords</span>, <span style="color: #D8DEE9;">_</span> = gmsh.model.mesh.getElementProperties(4)
        <span style="color: #D8DEE9;">jacobians</span>, <span style="color: #D8DEE9;">determinants</span>, <span style="color: #D8DEE9;">_</span> = gmsh.model.mesh.getJacobians(4, localCoords)
        <span style="color: #81A1C1;">self</span>.<span style="color: #D8DEE9;">jacobians</span> = jacobians.reshape(-1, 3, 3)
        <span style="color: #81A1C1;">self</span>.<span style="color: #D8DEE9;">determinants</span> = determinants
        <span style="color: #81A1C1;">pass</span>
 
</pre>
</div>
</div>
</div>
<div id="outline-container-org6e10cfb" class="outline-2">
<h2 id="org6e10cfb">Plotting in Matplotlib</h2>
<div class="outline-text-2" id="text-org6e10cfb">
<p>
Now that we have our <code>Mesh</code> class, lets test it out. In the <code>Mesh</code> class we made a bunch of connectivity matrices. Lets visualize some of these to get a feel for some of the information we will need in our discontinuous Galerkin algorithm.<br>
</p>

<p>
&#x2026; rest coming soon<br>
</p>
</div>
</div>
<div id="outline-container-orgedac1cd" class="outline-2">
<h2 id="orgedac1cd">References</h2>
<div class="outline-text-2" id="text-orgedac1cd">
<style>.csl-left-margin{float: left; padding-right: 0em;}
 .csl-right-inline{margin: 0 0 0 1em;}</style><div class="csl-bib-body">
  <div class="csl-entry"><a id="citeproc_bib_item_1"></a>
    <div class="csl-left-margin">1. </div><div class="csl-right-inline">Geuzaine C, Remacle JF. <a href="https://doi.org/10.1002/nme.2579">Gmsh: A three-dimensional finite element mesh generator with built-in pre- and post-processing facilities</a>. International journal for numerical methods in engineering. 2009;79(11):1309–31. </div>
  </div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<footer>
   <p>Go Van Go!</p>
   <a href="https://github.com/go-van-go" target="_blank" rel="noopener noreferrer">
     <i class="fa-brands fa-github githubfooter"></i>
   </a>
</footer>
</div>
</body>
</html>
