#+SETUPFILE: ./blog-styles.org
#+TITLE: DG Method From Scratch (in Python) - Gmsh 
#+SUBTITLE: Making a mesh and extracting information
#+HTML: <p class="date"><i>last update: Feb 4, 2025</i></p>

* Article Motivation 
#+BEGIN_QUOTE
- How do you make a mesh on Gmsh?
- How do I loop over elements or faces?
- How do I get the normal to each face?
- How do I find the boundary nodes and faces?
- Create a python class called ~Mesh~ with functions that return important information about the Gmsh mesh.
#+END_QUOTE

* Introduction
Gmsh is an *open source* 3D finite element mesh generator [cite:@geuzaine2009gmsh]. Let's use it to produce triangle and tetrahedral meshes. Then, we'll extract all the information we need to do a finite element simulation (like vertices for each cell, normal to each face, boundary faces, which elements are touching and on which face).

* Creating a 2D and 3D mesh in Gmsh
Let's create some meshes that we can use as examples.

We'll start with a 2D mesh. We'll make a simple ellipse and we'll do it using Gmsh's built in geometry kernel. We'll save the following as ~2d-ellipse.geo~

#+BEGIN_SRC gmsh
cm = 1e-02; // centimeters
a = 6 * cm; // Semi-major axis
b = 4 * cm; // Semi-minor axis
Lc = 0.01;  // characteristic cell length 

// Define center and ellipse points
Point(1) = {0, 0, 0, Lc};
Point(2) = {a, 0, 0, Lc};
Point(3) = {0, b, 0, Lc};
Point(4) = {-a, 0, 0, Lc};
Point(5) = {0, -b, 0, Lc};

// Define ellipse using center and points
Ellipse(1) = {2, 1, 3};
Ellipse(2) = {3, 1, 4};
Ellipse(3) = {4, 1, 5};
Ellipse(4) = {5, 1, 2};

// Define surface
Curve Loop(5) = {1, 2, 3, 4};
Plane Surface(6) = {5};
#+END_SRC

We can then run the following code to produce a ~.msh~ file, Gmsh's own file type for storing mesh data.

#+BEGIN_SRC bash
gmsh -2 2d-ellipse.geo -o 2d-ellipse.msh
#+END_SRC

Now let's use the /OpenCASCADE/ geometry Kernel that is available using Gmsh's python API. We'll create the following file called ~3d-torus.py~

#+BEGIN_SRC python
import gmsh
import sys

# initialize gmsh
gmsh.initialize(sys.argv)

# Same parameters as 2D problem
cm = 1e-02;
a = 6 * cm;
b = 4 * cm;
Lc = 0.01;

# Create an ellipse using OpenCASCADE
ellipse = gmsh.model.occ.addTorus(0, 0, 0, a, b)

# Synchronize the model
gmsh.model.occ.synchronize();

# Generate a 2D mesh
gmsh.model.mesh.generate(2)

# Save the mesh as a .msh file
gmsh.write("3d-torus.msh")

# Run the GUI
gmsh.fltk.run()

gmsh.finalize()
#+END_SRC

Running this python file with ~python 3d-torus.py~ will produce our 3D ~.msh~ file.

* Writing a Mesh class in python
#+BEGIN_emphasis
Our goal is to create a python class called ~Mesh~ that can easily provide the following information:
- ~dimension~ - dimension of mesh
- ~num_elements~ - number of elements in the mesh
- ~verticies[i]~ - coordinates for vertex ~i~ 
- ~edges2Elements[i]~ - the elements that include edge ~i~
- ~faces2Elements[i]~ - the elements that include face ~i~
- ~elements2Elements[i]~ - the elements adjacent to element ~i~
- ~normal[i]~ - the normal vector to face ~i~
- ~jacobians[i]~ - the jacobian matrix of element ~i~ (used for mapping from reference element)
- ~determinants[i]~ - the determinant of element ~i~'s Jacobian matrix (used for mapping from reference element)
#+END_emphasis
We can visualize the mesh using the built in GUI for Gmsh. However, were going to need to get a bunch of the information from Gmsh into numpy, so lets figure out how to do that.

#+BEGIN_extra
Naming conventions for meshes can vary from person to person. In this cite we'll stick to the following.

A *mesh* has *cells*. 3D cells (tetrahedron in our case) have *faces*, *edges*, and *vertices*. All of these are examples of *entities*.

An *element* refers to a *finite element* which can have quadrature points called *nodes*.

See the posts about [[https://govango.org/blogs/what-is-a-computational-mesh][meshes]] and [[https://govango.org/blogs/discontinuous-galerkin-method-from-scratch-in-python-the-finite-element][finite elements]] for more information.

Unfortunately Gmsh uses element and node terminology for meshes, so you might see them interchanged at times.
#+END_extra

The first thing we'll want to do is extract all the vertices and plot them using matplotlib. Lets create a python file called ~mesh-with-matplotlib.py~

Lets get familiar with some of the Gmsh functionality with the following simple code.

#+BEGIN_SRC python
import gmsh
import pdb

gmsh.initialize()
gmsh.open(file_path)

entities = gmsh.model.getEntities() 
breakpoint()
#+END_SRC

This puts us into the python debugger where we can start to poke around. Typing ~(PDB) entities~ returns the following:
#+BEGIN_SRC bash
[(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (1, 1), (1, 2), (1, 3), (1, 4), (2, 6)] # for 2d-ellipse.msh
[(0, 1), (1, 1), (1, 2), (2, 1), (3, 1)]  # for 3d-torus.msh 
#+END_SRC

This is a list of all the entities in the model as ~(dimension,tag)~ pairs.

So ~(0,1)~ means there is a point (zero dimensional object) with a tag of 1.

#+BEGIN_emphasis
/What is a tag in Gmsh?/

A tag is just a global identification model for the entity. It is strictly positive and, when combined with the dimension, uniquely defines any entity. From the documentation:

- each point must possess a unique tag;
- each curve must possess a unique tag;
- each surface must possess a unique tag;
- each volume must possess a unique tag. 
#+END_emphasis

Our ~2d-ellipse.msh~ has 5 points, 4 curves, and 1 surface.

Our ~3d-torus.msh~ file has 1 point, 2 curves, 1 surface, and 1 volume.

Using example 2.22 from [[https://gmsh.info/doc/texinfo/gmsh.html#x1][the official gmsh tutorial]], we can print the following information about our ~2d-ellipse.msh~ file.

#+BEGIN_SRC bash
Info    : Reading '2d-ellipse.msh'...
Info    : 10 entities
Info    : 114 nodes
Info    : 229 elements
Info    : Done reading '2d-ellipse.msh'
Entity (0, 1) of type Point
 - Mesh has 1 nodes and 1 elements
Entity (0, 2) of type Point
 - Mesh has 1 nodes and 1 elements
 - Upward adjacencies: [1 4]
Entity (0, 3) of type Point
 - Mesh has 1 nodes and 1 elements
 - Upward adjacencies: [1 2]
Entity (0, 4) of type Point
 - Mesh has 1 nodes and 1 elements
 - Upward adjacencies: [2 3]
Entity (0, 5) of type Point
 - Mesh has 1 nodes and 1 elements
 - Upward adjacencies: [3 4]
Entity (1, 1) of type Discrete curve
 - Mesh has 7 nodes and 8 elements
 - Upward adjacencies: [6]
 - Downward adjacencies: [2 3]
Entity (1, 2) of type Discrete curve
 - Mesh has 7 nodes and 8 elements
 - Upward adjacencies: [6]
 - Downward adjacencies: [3 4]
Entity (1, 3) of type Discrete curve
 - Mesh has 7 nodes and 8 elements
 - Upward adjacencies: [6]
 - Downward adjacencies: [4 5]
Entity (1, 4) of type Discrete curve
 - Mesh has 7 nodes and 8 elements
 - Upward adjacencies: [6]
 - Downward adjacencies: [5 2]
Entity (2, 6) of type Discrete surface
 - Mesh has 81 nodes and 192 elements
#+END_SRC

Luckily Gmsh allows to get a lot more information from the mesh. Fro example:

- We can get all the nodes (vertices) that lie on a boundary using ~gmsh.model.mesh.getElementEdgeNodes()~
- We can get the nodes on the faces of entities using ~gmsh.model.mesh.getElementFaceNodes()~
- We can get the Jacobian of an element using ~gmsh.model.mesh.getJacobians()~
- We can get the surface normal of every face

Since ~gmsh.model.mesh.getEdges()~ and ~gmsh.model.mesh.getFaces()~ return in the same order as the elements, we can do things like make a dictionary that tells us the connections between edges and elements, and faces and elements.

Using all this information, lets create a file called ~mesh.py~ and in that file well create the following python class called ~Mesh~.

#+BEGIN_SRC python
class Mesh3d:
    def __init__(self, msh_file):
        gmsh.initialize()
        gmsh.open(msh_file)

        self.num_vertices = 0
        self.num_elements = 0
        self.vertexCoordinates = []
        self.element2vertices = []
        self.element2elements = []
        self.element2faces = []
        self.faceNormals = []
        self.jacobians = {}
        self.determinants = {}
        
        self._extract_mesh_info()
        self._build_connectivityMatricies()
        self._compute_jacobians()

        gmsh.finalize()

    def _extract_mesh_info(self):
        # get vertex information 
        ntags, coords, _ = gmsh.model.mesh.getNodes(4)
        self.num_vertices= len(ntags)
        self.vertexCoordinates = coords.reshape(-1, 3)

        # get element information
        # get all the nodes from tetrahedrons (elementType = 4)
        nodeTags, _, _ = gmsh.model.mesh.getNodesByElementType(4) 
        self.num_elements = int(len(nodeTags)/4) 
        self.elements2vertices = nodeTags.reshape(-1, 4).astype(int)

    def _build_connectivityMatricies(self):
        """tetrahedral face connect algorithm from Toby Isaac"""
        num_faces = 4
        K = self.num_elements 
        EtoV = self.elements2vertices
        num_vertices = self.num_vertices 
        
        # create list of all faces
        faceVertices = np.vstack((EtoV[:, [0, 1, 2]],
                            EtoV[:, [0, 1, 3]],
                            EtoV[:, [1, 2, 3]],
                            EtoV[:, [0, 2, 3]]))
        # sort each row from low to high for hash algorithm
        faceVertices = np.sort(faceVertices, axis=1) - 1
         
        # unique hash for each set of three faces by their vertex numbers
        faceHashes = faceVertices[:, 0] * num_vertices * num_vertices  + \
                     faceVertices[:, 1] * num_vertices + \
                     faceVertices[:, 2] + 1

        # vertex id from 1 - num_vertices * num_elements
        vertex_ids = np.arange(1, num_faces*K+1)
       
        # set up default element to element and element to faces connectivity
        EtoE = np.tile(np.arange(1, K+1)[:, np.newaxis], (1, num_faces))
        EtoF = np.tile(np.arange(1, num_faces+1), (K, 1))

        # build a master matrix (mappingTable) that we will solve by 
        # sorting by one column to create the connectivity matricies
        mappingTable = np.column_stack((faceHashes,
                                        vertex_ids,
                                        np.ravel(EtoE, order='F'),
                                        np.ravel(EtoF, order='F')))
        
        # Now we sort by global face number.
        sorted_mapTable= np.array(sorted(mappingTable, key=lambda x: (x[0], x[1])))
        
        # find matches in the sorted face list
        matches = np.where(sorted_mapTable[:-1, 0] == sorted_mapTable[1:, 0])[0]
        
        # make links reflexive
        matchL = np.vstack((sorted_mapTable[matches], sorted_mapTable[matches + 1]))
        matchR = np.vstack((sorted_mapTable[matches + 1], sorted_mapTable[matches]))
        
        # insert matches
        EtoE_tmp = np.ravel(EtoE, order='F') - 1
        EtoF_tmp = np.ravel(EtoF, order='F') - 1
        EtoE_tmp[matchL[:, 1] - 1] = (matchR[:, 2] - 1)
        EtoF_tmp[matchL[:, 1] - 1] = (matchR[:, 3] - 1)
        
        EtoE = EtoE_tmp.reshape(EtoE.shape, order='F')
        EtoF = EtoF_tmp.reshape(EtoF.shape, order='F')

        self.element2elements = EtoE
        self.element2faces = EtoF

    def _compute_jacobians(self):
        # get local coordinates of the verticies in the
        # reference tetrahedron
        name, dim, order, numNodes, localCoords, _ = gmsh.model.mesh.getElementProperties(4)
        jacobians, determinants, _ = gmsh.model.mesh.getJacobians(4, localCoords)
        self.jacobians = jacobians.reshape(-1, 3, 3)
        self.determinants = determinants
        pass
 
#+END_SRC

* Plotting in Matplotlib
Now that we have our ~Mesh~ class, lets test it out. In the ~Mesh~ class we made a bunch of connectivity matrices. Lets visualize some of these to get a feel for some of the information we will need in our discontinuous Galerkin algorithm.

... rest coming soon

* References
#+print_bibliography:
